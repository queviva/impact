<!doctype html><html>
    
<head><title>gravgrid</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

* {
    box-sizing: border-box;
    word-wrap: break-word;
    --hue: 48;
    --sat: 100%;
    --lit: 88%;
    --color: hsl(var(--hue),var(--sat),var(--lit));
    --backcolor: hsl(120, 100%, 13%);
    --litback: hsla(120,50%,25%);
    --dotcolor: var(--color);
}

body {
    padding: 0px;
    margin: 0px;
    hyphens: auto;
}

#holder {
    padding: 10px;
    font-size: 24px;
    text-align: justify;
    max-width: 700px;
    margin: auto;
    border: 1px solid #000;
    background-color: var(--backcolor);
    color: var(--color);
    z-index: 2;
}

div {
    position: relative;
    padding: 10px;
}

img {
    width: 100%;
    max-width: 400px;
}

a, a:visited {
    color: var(--color);
    text-decoration: none;
    transition: 300ms linear color;
}

a:hover {
    color: #e86;
    transition: 300ms linear color;
}

input {
    --thumbH : 30px;
    --color: 48, 100%;
    --lightness: 88%;
    --midness:  var(--lightness);/*calc(0.37 * var(--lightness));*/
}

input[type=range] {
    -webkit-appearance: none;
    -moz-appearance: none;
    display: inline-block;
    padding: 0;
    margin: 0;
    height: var(--thumbH);
    width: 100%;
    border-radius: calc(var(--thumbH) / 2);
    background-color: hsla(0,100%,100%,0.3);
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: hsl(var(--color), var(--lightness));
    opacity: 1.7;
    height: var(--thumbH);
    margin-bottom: 0px;
    width: var(--thumbH);
    border: calc(0.1 * var(--thumbH)) solid;
    border-color: var(--backcolor);
    border-radius: calc(var(--thumbH) / 2);
}

input[type=range]:focus {
    outline: none;
}
</style>
<style>

svg {
    width: 100%;
    padding: 0;
    margin: 0;
}

#svgHolder {
    border: 10px solid hsla(0,100%,100%,0.3);
    position: relative;
    padding: 0;
    margin: 0;
    width: 100%;
    padding-top: calc(40% - 7px);
    overflow: hidden;
}

#svgGrid {
    padding: 0; margin: 0;
    position: absolute;
    top:0;
    overflow: visible;
    xxxtransform: perspective(400px) rotateX(45deg);
    z-index:-1;
}

#svgMass {
    padding: 0; margin: 0;
    top:0;
    position: absolute;
    xxxoverflow hidden;
}

.gridline {
    stroke-width: 4;
    stroke: var(--dotcolor);
    stroke-linecap: round;
    fill: none;
    vector-effect: non-scaling-stroke;
}

.xlineDots {
    marker-start: url(#dot);
    marker-mid: url(#dot);
    marker-end: url(#dot);
}

.xline {
    
}

.yline {
    xstroke: red;
}

.axisline{
    xxxstroke-width: 1;
    stroke: orange;
    vector-effect: non-scaling-stroke;
}

.mass {
    xxopacity: 1.5;
    fill: #ea0;
    stroke: hsla(
        var(--hue),calc(0.8 * var(--sat)),calc(0.4 * var(--lit)),0.8
    );
    stroke-width: 8;
    vector-effect: non-scaling-stroke;
    xxxtransition: r 0.3s cubic-bezier(0.3, 1.2, 0.6, 1.6);
}

</style>
</head>

<body>
<div id="holder">
    
    <div>grav gr!d</div>
    
    <div id="svgHolder">
        
        <svg id="svgGrid"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
         preserveAspectRatio="none"
        >
            <defs>
                <marker id="dot" refX="10" refY="10"
                 vector-effect="non-scaling-size"
                 markerUnits="userSpaceOnUse"
                 markerWidth="20"
                 markerHeight="20"
                 orient="auto"
                >
                    <circle cx="10" cy="10" r="0.8"
                     vector-effect="non-scaling-size"
                     fill="var(--dotcolor)"
                     stroke="none"
                    ></circle>
                </marker>
        
                
            </defs>
            
            <g id="ylines"></g>
            <g id="xlines"></g>
            
        </svg>
        
        <svg id="svgMass"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
        >
            <g id="massgroup"></g>
            
        </svg>
        
    </div>
    
    <div id="slideDiv" style="padding:10px 0px;margin:0;">
        <input
         id="slide0"
         type="range"
         min="0"
         max="100"
         step="1"
         value="0"
        />
    </div>
    
    <div id="sig" style="text-align:right;width:100%"><i>~queviva</i></div>
    
</div>
</body>

<script id="gravscript">

new Date() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>
  document.addEventListener('DOMContentLoaded', () => {
    
        // prefs {
        let count = 0;
    
        const bigG = 1;
    
        const size = 5;
        const lineWidth = 2;
        const useDots = false;
        const xdim = 140;
        const ydim = 80;
        const valScale = 5.2;
    
        let masses = [
            [-20, -7, 12]
        ];
    
        //}
    
        // refs {
    
        const NS = 'http://www.w3.org/2000/svg';
        const svgHolder = document.getElementById('svgHolder');
        const xaxis = document.getElementById('xaxis');
        const yaxis = document.getElementById('yaxis');
        const xlines = document.getElementById('xlines');
        const ylines = document.getElementById('ylines');
        const massgroup = document.getElementById('massgroup');
    
        let allPts = (new Array(1 +
        (2 * ydim / size)
        )).fill(0);
        let yPts = [];
        let canUpdate = true;
    
        //}
    
        // methods and objects {
    
        function Point(x, y) {
    
            this.ox = x;
            this.oy = y;
            this.x = x;
            this.y = y;
            this.theta = Math.atan2(masses[0].y - y, masses[0].x - x);
            this.cos = Math.cos(this.theta).toFixed(3);
            this.sin = Math.sin(this.theta).toFixed(3);
            
            this.xsign = Math.sign(x - masses[0].x);
            this.ysign = Math.sign(y - masses[0].y);
            
            this.acc = [];
    
            for (let i in masses) {
                let dist = Math.sqrt(
                    Math.pow((masses[i].x - this.x), 2) +
                    Math.pow((masses[i].y - this.y), 2)
                );
                this.acc[i] = dist === 0 ? 0 : bigG * (1 / (dist * dist));
            }
    
        }
    
        Point.prototype.recalc = function(dT = 0) {
    
            let D = (1 / 2) * this.acc[0] * dT * dT;
    
            this.x = this.ox + D * this.cos;
            this.y = this.oy + D * this.sin;
    
            if (
                this.xsign !== Math.sign(this.x - masses[0].x) ||
                this.ysign !== Math.sign(this.y - masses[0].y)
            ) {
                this.x = masses[0].x;
                this.y = masses[0].y;
            }
    
        };
    
        Point.prototype.makeSVG = function() {
            return this.x + ' ' + this.y + ' ';
        }
    
        function Mass(x, y, r, off = 12) {
    
            this.ox = x;
            this.oy = y;
            this.or = r;
            this.x = x;
            this.y = y;
            this.r = r;
    
            this.off = off;
            this.set = r / (100 - off);
    
            this.obj = document.createElementNS(NS, 'circle');
            this.obj.setAttribute('cx', x);
            this.obj.setAttribute('cy', y);
            this.obj.setAttribute('r', r);
            this.obj.classList.add('mass');
    
            massgroup.appendChild(this.obj);
    
        }
    
        Mass.prototype.recalc = function(val) {
    
            this.obj.setAttribute('r', (
                this.r = val / valScale < this.off ?
                0 : this.set * (val / valScale - this.off)
            ));
    
        };
    
        function createXlines() {
    
            for (let L in allPts) {
    
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add(
                    'gridline',
                    allPts[L][0].y === 0 ? 'axisline' : 'xline'
                );
                
                if (useDots) {
                    tmpL.classList.add('xlineDots');
                }
    
                tmpL.style.strokeWidth = allPts[L][0].y === 0 ? 1 : lineWidth;
    
                xlines.appendChild(tmpL);
    
            }
    
        }
    
        function createYlines() {
    
            for (let L of allPts[0]) {
    
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add(
                    'gridline',
                    L.x === 0 ? 'axisline' : 'yline'
                );
    
                tmpL.style.strokeWidth = L.x === 0 ? 1 : lineWidth;
    
                ylines.appendChild(tmpL);
    
            }
    
        }
    
        function drawXlines() {
    
            for (let L in allPts) {
    
                // grab all positive points in the scope
                let pozz = allPts[L].filter(P => {
    
                    return (Math.abs(P.x) < 56 && Math.abs(P.y) < 30);
    
                });
    
                // if there are any positive points ...
                if (pozz.length !== 0) {
    
                    // initialize positive line with first point
                    let posD = 'M' + pozz[0].makeSVG();
    
                    // remove that point
                    pozz.shift();
    
                    // loop through all remaining points
                    pozz.forEach(P => posD += 'L' + P.makeSVG());
    
                    // add the path to the svg line
                    xlines.childNodes[L].setAttribute('d', posD);
    
                }
    
            }
    
        }
    
        function drawYlines() {
    
            for (let L in yPts) {
    
                // grab all positive points in the scope
                let pozz = yPts[L].filter(P => {
    
                    return (Math.abs(P.x) < 56 && Math.abs(P.y) < 30);
    
                });
    
                // if there are any positive points ...
                if (pozz.length !== 0) {
    
                    // initialize positive line with first point
                    let posD = 'M' + pozz[0].makeSVG();
    
                    // remove that point
                    pozz.shift();
    
                    // loop through all remaining points
                    pozz.forEach(P => posD += 'L' + P.makeSVG());
    
                    // add the path to the svg line
                    ylines.childNodes[L].setAttribute('d', posD);
    
                }
    
            }
    
        }
    
        function update(val = 0) {
    
            // recalc the masses
            masses.forEach(M => M.recalc(val * valScale));
    
            // recalc the grid points
            for (let AP of allPts) {
    
                for (let p of AP) {
                    p.recalc(val * valScale);
                }
    
            }
    
            // draw the x-lines
            drawXlines();
    
            // draw the y-lines
            drawYlines();
    
        }
    
        //}
    
        ////////////////////////////////////////////////////////////
    
        // create the masses {
        for (let M in masses) { masses[M] = new Mass(...masses[M]); }
        //}
    
        // fill the points array {
        for (let L in allPts) {
            allPts[L] = (new Array(1 + (2 * xdim / size))).fill(0);
            for (let P in allPts[L]) {
                allPts[L][P] = new Point(-xdim + P * size, -ydim + L * size);
            }
        }
    
        // rotate that matrix for y-lines
        for (let L in allPts[0]) {
    
            yPts[L] = [];
    
            for (let i = 0, j = allPts.length; i < j; i++) {
                yPts[L].push(allPts[i][L]);
            }
    
        }
        //}
    
        // create the lines {
        createXlines();
        createYlines();
        //}
    
        // draw the scene {
        update();
        //}
    
        ////////////////////////////////////////////////////////////
    
        // handlers {
    
        for (let [x, y, z] of [
    
                [svgHolder, 'wheel', e => {
    
                    e.preventDefault();
                    count = [0, (count + e.deltaX / 20), 100].sort((a, b) => a - b)[1];
                    slide0.value = count;
    
                }],
    
                [slide0, 'input', e => {
                    count = parseInt(slide0.value);
                }],
    
            ]) {
            x.addEventListener(y, e => {
                    z(e);
                    update(Math.round(count));
            });
        }
        //}
    
}))()

=== undefined || (console.log('eXp!red'));

</script>

</html>