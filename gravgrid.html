<!doctype html><html>
    
<head><title>gravgrid</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

* {
    box-sizing: border-box;
    word-wrap: break-word;
    --hue: 48;
    --sat: 100%;
    --lit: 88%;
    --color: hsl(var(--hue),var(--sat),var(--lit));
    --backcolor: hsl(120, 100%, 13%);
    --litback: hsla(120,50%,25%);
    --dotcolor: var(--color);
}

body {
    padding: 0px;
    margin: 0px;
    background-color: #000;
    hyphens: auto;
}

#holder {
    padding: 10px;
    font-size: 24px;
    text-align: justify;
    max-width: 700px;
    width: 100%;
    margin: auto;
    border: 1px solid #000;
    background-color: var(--backcolor);
    color: var(--color);
    z-index: 2;
}

div {
    position: relative;
    padding: 10px;
}

img {
    width: 100%;
    max-width: 400px;
}

a, a:visited {
    color: var(--color);
    text-decoration: none;
    transition: 300ms linear color;
}

a:hover {
    color: #e86;
    transition: 300ms linear color;
}

input {
    --thumbH : 40px;
    --color: 48, 100%;
    --lightness: 88%;
    --midness:  var(--lightness);/*calc(0.37 * var(--lightness));*/
}

input[type=range] {
    -webkit-appearance: none;
    -moz-appearance: none;
    display: inline-block;
    padding: 0;
    margin: 0;
    height: var(--thumbH);
    width: 100%;
    border-radius: calc(var(--thumbH) / 2);
    background-color: hsla(0,100%,100%,0.3);
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: hsl(var(--color), var(--lightness));
    opacity: 1.7;
    height: var(--thumbH);
    margin-bottom: 0px;
    width: var(--thumbH);
    border: calc(0.1 * var(--thumbH)) solid;
    border-color: var(--backcolor);
    border-radius: calc(var(--thumbH) / 2);
}

input[type=range]:focus {
    outline: none;
}

</style>
<style>

svg {
    width: 100%;
    padding: 0;
    margin: 0;
}

#svgHolder {
    border: 10px solid hsla(0,100%,100%,0.3);
    position: relative;
    padding: 0;
    margin: 0;
    width: 100%;
    padding-top: calc(40% - 7px);
    overflow: hidden;
}

#svgGrid {
    padding: 0; margin: 0;
    position: absolute;
    top:0;
    overflow: visible;
    xxxtransform: perspective(400px) rotateX(45deg);
    z-index:-1;
}

#svgMass {
    padding: 0; margin: 0;
    top:0;
    position: absolute;
    xxxoverflow hidden;
}

.gridline {
    stroke-width: 4;
    stroke: var(--dotcolor);
    stroke-linecap: round;
    fill: none;
    vector-effect: non-scaling-stroke;
}

.xlineDots {
    marker-start: url(#dot);
    marker-mid: url(#dot);
    marker-end: url(#dot);
}

.xline {
    
}

.yline {

    
}

.axisline{
    xxxstroke-width: 1;
    stroke: orange;
    vector-effect: non-scaling-stroke;
}

.mass {
    xxopacity: 1.5;
    fill: #ea0;
    stroke: hsla(
        var(--hue),calc(0.8 * var(--sat)),calc(0.4 * var(--lit)),0.8
    );
    stroke-width: 8;
    vector-effect: non-scaling-stroke;
    xxxtransition: r 0.3s cubic-bezier(0.3, 1.2, 0.6, 1.6);
}

</style>
</head>

<body>
<div id="holder">
    
    <div>grav gr!d</div>
    
    <div id="svgHolder">
        
        <svg id="svgGrid"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
         preserveAspectRatio="none"
        >
            <defs>
                
                <marker id="dot" refX="10" refY="10"
                 vector-effect="non-scaling-size"
                 markerUnits="userSpaceOnUse"
                 markerWidth="20"
                 markerHeight="20"
                 orient="auto"
                >
                    <circle cx="10" cy="10" r="0.4"
                     vector-effect="non-scaling-size"
                     fill="var(--dotcolor)"
                     stroke="none"
                    ></circle>
                </marker>
        
                
            </defs>
            
            <!--path id="test" stroke="#d00" stroke-width="0.2"
            d="M-28 -8 L28 8"
            ></path-->
            <g id="ylines"></g>
            <g id="xlines"></g>
            
        </svg>
        
        <svg id="svgMass"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
        >
            <g id="massgroup"></g>
            

        </svg>
        
    </div>
    
    <div id="slideDiv" style="padding:10px 0px;margin:0;">
        <input
         id="slide0"
         type="range"
         min="0"
         max="100"
         step="1"
         value="0"
        />
    </div>
    
    <div id="sig" style="text-align:right;width:100%"><i>~queviva</i></div>
    
</div>
</body>

<script id="gravscript">

new Date() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>

  document.addEventListener('DOMContentLoaded', () => {
    
        // prefs {
        let count = 0;
    
        const bigG = 1;
    
        const size = 2;
        const lineWidth = 0.4;
        const useDots = false;
        const xdim = 140;
        const ydim = 80;
        const valScale = 1.2;
    
        let masses = [
             //[0, 0, 12, 0]
             [-21, -8, 8, 0]
            ,[ 21,  8, 8, 0]
            //,[ 32, -10, 2, 0]
        ];
    
        //}
    
        // refs {
    
        const NS = 'http://www.w3.org/2000/svg';
        const svgHolder = document.getElementById('svgHolder');
        const xaxis = document.getElementById('xaxis');
        const yaxis = document.getElementById('yaxis');
        const xlines = document.getElementById('xlines');
        const ylines = document.getElementById('ylines');
        const massgroup = document.getElementById('massgroup');
    
        let allPts = (new Array(1 + (2 * ydim / size))).fill(0);
        let yPts = [];
    
        //}
    
        // methods and objects {
    
        function Point(x, y) {
    
            this.ox = x;
            this.oy = y;
            this.x = x;
            this.y = y;
            this.rendX = x;
            this.rendY = y;
            
            this.theta = [];
            this.cos = [];
            this.sin = [];
            this.acc = [];
            
            this.xsign = [];
            this.ysign = [];
            
            this.threshold = Infinity;
            
    
            for (let i in masses) {
                
                let dist = Math.sqrt(
                    Math.pow((masses[i].x - this.x), 2) +
                    Math.pow((masses[i].y - this.y), 2)
                );
                
                this.theta[i] = Math.atan2(masses[i].y - y, masses[i].x - x);
                this.cos[i] = Math.cos(this.theta[i]);
                this.sin[i] = Math.sin(this.theta[i]);
                this.acc[i] = dist === 0 ? 0 : bigG / (dist * dist);
                
                this.xsign[i] = Math.sign(this.ox - masses[i].x);
                this.ysign[i] = Math.sign(this.oy - masses[i].y);
                
            }
    
        }
    
        Point.prototype.recalc = function(dT = 0) {
            
    
            let dx = 0;
            let dy = 0;
    
            for (let i in masses) {
                
                let dist = Math.sqrt(
                    Math.pow((masses[i].x - this.x), 2) +
                    Math.pow((masses[i].y - this.y), 2)
                );
                
                let theta = Math.atan2(
                    masses[i].y - this.y,
                    masses[i].x - this.x
                );
                
                let cos = Math.cos(theta);
                let sin = Math.sin(theta);
                //let acc = dist === 0 ? 0 : bigG / (dist * dist);
                //let vel = this.acc[i] * dT;
            
                //let D = (1 / 2) * acc * dT * dT;
                let D = this.acc[i] * dT * dT;
            
                dx += D * cos;
                dy += D * sin;
                
            }
    
            this.x += dx;
            this.y += dy;
            
            if (dT > this.threshold) {
                return;
            }
            
            this.rendX = this.x;
            this.rendY = this.y;
            
            for (let i in masses) {
                
                if (
                    
                    Math.sqrt(dx*dx + dy*dy) >
                    Math.sqrt(
                        Math.pow((masses[i].x - this.x), 2) +
                        Math.pow((masses[i].y - this.y), 2)
                    )
                    
                ) {
                    
                    this.threshold = dT;
                    this.rendX = masses[i].x;
                    this.rendY = masses[i].y;
                    break;
                    
                }
            }
    
        };
    
        Point.prototype.makeSVG = function() {
            return this.rendX.toFixed(3) + ' ' + this.rendY.toFixed(3) + ' ';
        };
    
        function Mass(x, y, r, off = 12) {
    
            this.ox = x;
            this.oy = y;
            this.or = r;
            this.x = x;
            this.y = y;
            this.r = r;
    
            this.off = off;
            this.set = r / (100 - off);
    
            this.obj = document.createElementNS(NS, 'circle');
            this.obj.setAttribute('cx', x);
            this.obj.setAttribute('cy', y);
            this.obj.setAttribute('r', r);
            this.obj.classList.add('mass');
            //this.obj.innerHTML = '<animate attributeName="stroke-width" begin="0s" dur="0.5s" repeatCount="indefinite" from="0" to="8"/>';
    
            massgroup.appendChild(this.obj);
    
        }
    
        Mass.prototype.recalc = function(val) {
    
            this.obj.setAttribute('r', (
                this.r = val / valScale < this.off ?
                0 : this.set * (val / valScale - this.off)
            ));
    
        };
    
        function createXlines() {
    
            for (let L in allPts) {
    
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add(
                    'gridline',
                    allPts[L][0].y === 0 ? 'axisline' : 'xline'
                );
                
                if (useDots) {
                    tmpL.classList.add('xlineDots');
                }
                
                //tmpL.style.stroke = 'hsl('+5+Math.random()*30+',100%,50%)';
                
                /*
                if (allPts[L][0].y !== 0) {
                    tmpL.style.display = 'none';
                }
                */
    
                tmpL.style.strokeWidth = lineWidth;
                
                if (allPts[L][0].y === 0) {
                    tmpL.style.strokeWidth = 2;
                    tmpL.style.strokeWidth = 2;
                }
    
                xlines.append(tmpL)
    
            }
    
        }
    
        function createYlines() {
    
            for (let L of allPts[0]) {
    
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add(
                    'gridline',
                    L.x === 0 ? 'axisline' : 'yline'
                );
                
                tmpL.style.strokeWidth = L.x === 0 ? 2 : lineWidth;
                //tmpL.style.strokeWidth = lineWidth;
    
                ylines.appendChild(tmpL);
    
            }
    
        }
    
        function drawXlines() {
    
            for (const [n, L] of allPts.entries()) {
    
                // grab all positive points in the scope
                let pozz = L.filter((P, i) => {
    
                    // oy! you have to store the index value
                    P.idx = i;
                    
                    // this just has to be visually adjusted
                    return (
                        true
                        //(Math.abs(P.x) < 50 && Math.abs(P.y) < 22)
                        //||
                        //(Math.abs(P.prev.x) < 50 && Math.abs(P.prev.y) < 22)
                    );
    
                });
    
                // if there are any positive points ...
                if (pozz.length !== 0) {
                
                    // start line at previous point
                    //let posD = 'M' + L[pozz[0].idx - 1].makeSVG();
                    let posD = 'M' + L[0].makeSVG();
                    pozz.shift();
                    
                    // loop through all remaining points
                    pozz.forEach(P => posD += 'L' + P.makeSVG());
                    
                    // end line with extra point
                    //posD += 'L' +
                    //L[pozz[pozz.length-1].idx + 1].makeSVG();
    
                    // add the path to the svg line
                    xlines.childNodes[n].setAttribute('d', posD);
    
                }
    
            }
    
        }
    
        function drawYlines() {
    
            for (let L in yPts) {
    
                // grab all positive points in the scope
                let pozz = yPts[L].filter(P => {
    
                    return true;//(Math.abs(P.x) < 56 && Math.abs(P.y) < 30);
    
                });
    
                // if there are any positive points ...
                if (pozz.length !== 0) {
    
                    // initialize positive line with first point
                    let posD = 'M' + pozz[0].makeSVG();
    
                    // remove that point
                    pozz.shift();
    
                    // loop through all remaining points
                    pozz.forEach(P => posD += 'L' + P.makeSVG());
    
                    // add the path to the svg line
                    ylines.childNodes[L].setAttribute('d', posD);
    
                }
    
            }
    
        }
        
        function update(val = 0) {

            // recalc the masses
            masses.forEach(M => M.recalc(val * valScale));
    
            // recalc the grid points
            for (let AP of allPts) {
    
                for (let p of AP) {
                    p.recalc(val * valScale);
                }
    
            }
    
            // draw the x-lines
            drawXlines();
    
            // draw the y-lines
            drawYlines();
    
        }
    
        //}
    
        ////////////////////////////////////////////////////////////
    
        // create the masses {
        for (let M in masses) { masses[M] = new Mass(...masses[M]); }
        //}
    
        // fill the points array {
        for (let L in allPts) {
            allPts[L] = (new Array(1 + (2 * xdim / size))).fill(0);
            for (let P in allPts[L]) {
                allPts[L][P] = new Point(-xdim + P * size, -ydim + L * size);
            }
        }
    
        // rotate that matrix for y-lines
        for (let L in allPts[0]) {
    
            yPts[L] = [];
    
            for (let i = 0, j = allPts.length; i < j; i++) {
                yPts[L].push(allPts[i][L]);
            }
    
        }
        //}
    
        // create the lines {
        createXlines();
        createYlines();
        //}
    
        // draw the scene {
        update();
        //}
    
        ////////////////////////////////////////////////////////////
    
        // handlers {
    
        for (let [x, y, z] of [
    
                [svgHolder, 'wheel', e => {
    
                    e.preventDefault();
                    count = [0, (count + e.deltaX / 20), 100].sort((a, b) => a - b)[1];
                    slide0.value = count;
    
                }],
    
                [slide0, 'input', e => {
                    count = parseInt(slide0.value);
                }],
                
                [svgHolder, 'dblclick', e => {
                    e.preventDefault();
                    slide0.value = (count = 0);
                }]
    
            ]) {
            x.addEventListener(y, e => {
                    z(e);
                    update(Math.round(count));
            }, {passive:false});
        }
        //}
    
}))()

=== undefined || (console.log('eXp!red'));

</script>

</html>