<!doctype html><html>
    
<head><title>gravgrid</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>

* {
    box-sizing: border-box;
    word-wrap: break-word;
    --hue: 48;
    --sat: 100%;
    --lit: 88%;
    --color: hsl(var(--hue),var(--sat),var(--lit));
    --backcolor: hsl(120, 100%, 13%);
    --litback: hsla(120,50%,25%);
    --dotcolor: var(--color);
}

body {
    padding: 0px;
    margin: 0px;
    background-color: #000;
    hyphens: auto;
}

#holder {
    padding: 10px;
    font-size: 24px;
    text-align: justify;
    max-width: 700px;
    width: 100%;
    margin: auto;
    border: 1px solid #000;
    background-color: var(--backcolor);
    color: var(--color);
    z-index: 2;
}

div {
    position: relative;
    padding: 10px;
}

img {
    width: 100%;
    max-width: 400px;
}

a, a:visited {
    color: var(--color);
    text-decoration: none;
    transition: 300ms linear color;
}

a:hover {
    color: #e86;
    transition: 300ms linear color;
}

input {
    --thumbH : 40px;
    --color: 48, 100%;
    --lightness: 88%;
    --midness:  var(--lightness);/*calc(0.37 * var(--lightness));*/
}

input[type=range] {
    -webkit-appearance: none;
    -moz-appearance: none;
    display: inline-block;
    padding: 0;
    margin: 0;
    height: var(--thumbH);
    width: 100%;
    border-radius: calc(var(--thumbH) / 2);
    background-color: hsla(0,100%,100%,0.3);
}

input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    background-color: hsl(var(--color), var(--lightness));
    opacity: 1.7;
    height: var(--thumbH);
    margin-bottom: 0px;
    width: var(--thumbH);
    border: calc(0.1 * var(--thumbH)) solid;
    border-color: var(--backcolor);
    border-radius: calc(var(--thumbH) / 2);
}

input[type=range]:focus {
    outline: none;
}

</style>
<style>

svg {
    width: 100%;
    padding: 0;
    margin: 0;
}

#svgHolder {
    border: 10px solid hsla(0,100%,100%,0.3);
    position: relative;
    padding: 0;
    margin: 0;
    width: 100%;
    padding-top: calc(40% - 7px);
    overflow: hidden;
}

#svgGrid {
    padding: 0; margin: 0;
    position: absolute;
    top:0;
    overflow: visible;
    xxxtransform: perspective(400px) rotateX(45deg);
    z-index:-1;
}

#svgMass {
    padding: 0; margin: 0;
    top:0;
    position: absolute;
    xxxoverflow hidden;
}

.gridline {
    stroke-width: 1;
    stroke: var(--dotcolor);
    stroke-linecap: round;
    fill: none;
    vector-effect: non-scaling-stroke;
}

.xlineDots {
    marker-start: url(#dot);
    marker-mid: url(#dot);
    marker-end: url(#dot);
}

.xline {
    
}

.yline {

    
}

.axisline{
    fill: none;
    stroke: #e90;
    stroke-width: 1;
    vector-effect: non-scaling-stroke;
}

.mass {
    xxopacity: 1.5;
    fill: #e90;
    stroke : #c70;
    xxxstroke: hsla(
        var(--hue),calc(0.8 * var(--sat)),calc(0.4 * var(--lit)),0.8
    );
    stroke-width: 5;
    vector-effect: non-scaling-stroke;
    xxxtransition: r 0.3s cubic-bezier(0.3, 1.2, 0.6, 1.6);
}

</style>
</head>

<body>
<div id="holder">
    
    <div>grav&middot;LoX</div>
    
    <div id="svgHolder">
        
        <svg id="svgGrid"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
         preserveAspectRatio="none"
        >
            <defs>
                
                <marker id="dot" refX="10" refY="10"
                 vector-effect="non-scaling-size"
                 markerUnits="userSpaceOnUse"
                 markerWidth="20"
                 markerHeight="20"
                 orient="auto"
                >
                    <circle cx="10" cy="10" r="0.4"
                     vector-effect="non-scaling-size"
                     fill="var(--dotcolor)"
                     stroke="none"
                    ></circle>
                </marker>
        
                
            </defs>
            
            <g id="ylines"></g>
            <g id="xlines"></g>
            <path id="xaxis" class="axisline"></path>
            <path id="yaxis" class="axisline"></path>
            
        </svg>
        
        <svg id="svgMass"
         xmlns:xlink="http://www.w3.org/2000/svg"
         width="100%"
         viewbox="-50 -20 100 40"
        >
            <g id="massgroup"></g>
            

        </svg>
        
    </div>
    
    <!--div id="slideDiv" style="padding:10px 0px;margin:0;">
        <input
         id="slide0"
         type="range"
         min="0"
         max="100"
         step="1"
         value="0"
        />
    </div-->
    
    <div id="sig" style="text-align:right;width:100%"><i>~queviva</i></div>
    
</div>
</body>

<script id="gravscript">

// expiration date {
new Date() < new Date('2023-10-13') &&

((dset = document.currentScript.dataset) =>

  document.addEventListener('DOMContentLoaded', () => {
      
//}
    
        ////////////////////////////////////////////////////////////
        
        // prefs {
    
        const size = 2;
        const lineWidth = 0.4;
        const axisWidth = 1.5;
        const xdim = 140;
        const ydim = 80;
        const valScale = 0.8;
        
        const useDots = false;
        const aniMass = false;
    
        const bigG = 1;
        
        let masses = [
            // equilateral {
            //[ 0, -12, 5, 0],
            //[-12,  4, 5, 0],
            //[ 12,  4, 5, 0]
            // }
            
            // [0, 0, 12, 0]
             [-22, -8, 5, 0]
            ,[ 26,  8, 3, 0]
            //,[ 32, -10, 2, 0]
        ];
    
        //}
    
        // refs {
        
        let count = 0;
    
        const NS = 'http://www.w3.org/2000/svg';
        const xaxis = document.getElementById('xaxis');
        const yaxis = document.getElementById('yaxis');
        const xlines = document.getElementById('xlines');
        const ylines = document.getElementById('ylines');
        const massgroup = document.getElementById('massgroup');
    
        let allPts = (new Array(1 + (2 * ydim / size))).fill(0);
        let yPts = [];
    
        //}
    
        // methods and objects {
        
        const getDist = (A, B) => Math.sqrt( //{
            Math.pow(A.x - B.x, 2) +
            Math.pow(A.y - B.y, 2)
        ); //}
    
        function Point(x, y) {
    
            this.ox = x;
            this.oy = y;
            this.x = x;
            this.y = y;
            this.rendX = x;
            this.rendY = y;
            
            this.mem = new Array(100);
            
            this.theta = [];
            this.cos = [];
            this.sin = [];
            this.acc = [];
            
            this.xsign = [];
            this.ysign = [];
            
            this.threshold = Infinity;
            
    
            for (let i in masses) {
                
                let dist = Math.sqrt(
                    Math.pow((masses[i].x - this.x), 2) +
                    Math.pow((masses[i].y - this.y), 2)
                );
                
                this.theta[i] = Math.atan2(masses[i].y - y, masses[i].x - x);
                this.cos[i] = Math.cos(this.theta[i]);
                this.sin[i] = Math.sin(this.theta[i]);
                this.acc[i] = dist === 0 ? 0 : bigG / (dist * dist);
                
                this.xsign[i] = Math.sign(this.ox - masses[i].x);
                this.ysign[i] = Math.sign(this.oy - masses[i].y);
                
            }
    
        }
    
        Point.prototype.recalc = function() {
            
            let dT = count * valScale;
            
            if (this.mem[count]) {
                this.x = this.rendX = this.mem[count].x;
                this.y = this.rendY = this.mem[count].y;
                return;
            }
            
            if (dT > this.threshold) {
                return;
            }
            
            let dx = 0;
            let dy = 0;
    
            for (let i in masses) {
                
                let theta = Math.atan2(
                    masses[i].y - this.y,
                    masses[i].x - this.x
                );
                
                let D = this.acc[i] * dT * dT;
                
                dx += D * Math.cos(theta);
                dy += D * Math.sin(theta);
                
            }
    
            this.x += dx;
            this.y += dy;
            
            this.rendX = this.x;
            this.rendY = this.y;
            
            for (let i in masses) {
                
                if (Math.sqrt(dx*dx + dy*dy) > getDist(masses[i], this)) {
                    
                    this.threshold = dT;
                    this.rendX = masses[i].x;
                    this.rendY = masses[i].y;
                    break;
                    
                }
            }
            
            this.mem[count] = { x: this.rendX, y: this.rendY };
    
        };
    
        Point.prototype.makeSVG = function() {
            return this.rendX.toFixed(3) + ' ' + this.rendY.toFixed(3) + ' ';
        };
    
        function Mass(x, y, r, off = 12) {
    
            this.ox = x;
            this.oy = y;
            this.or = r;
            this.x = x;
            this.y = y;
            this.r = r;
    
            this.off = off;
            this.set = r / (100 - off);
    
            this.obj = document.createElementNS(NS, 'circle');
            this.obj.setAttribute('cx', x);
            this.obj.setAttribute('cy', y);
            this.obj.setAttribute('r', r);
            this.obj.classList.add('mass');
            
            if (aniMass) {
                this.obj.innerHTML = '<animate attributeName="stroke-width" begin="0s" dur="0.5s" repeatCount="indefinite" from="0" to="8"/>';
            }
    
            massgroup.appendChild(this.obj);
    
        }
    
        Mass.prototype.recalc = function(val) {
    
            this.obj.setAttribute('r', (
                this.r = val / valScale < this.off ?
                0 : this.set * (val / valScale - this.off)
            ));
    
        };
    
        function createXlines() {
    
            for (let L of allPts) {
                
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add('gridline', 'xline');
                
                if (useDots) { tmpL.classList.add('xlineDots'); }
                
                if (L[0].y === 0) {
                    tmpL.style.display = 'none';
                }
    
                tmpL.style.strokeWidth = lineWidth;
                
                xlines.append(tmpL);
    
            }
    
        }
    
        function createYlines() {
    
            for (let L of allPts[0]) {
    
                let tmpL = document.createElementNS(NS, 'path');
    
                tmpL.classList.add('gridline', 'yline');
                
                if (L.ox === 0) { tmpL.style.display = 'none'; }
                
                tmpL.style.strokeWidth = lineWidth;
    
                ylines.appendChild(tmpL);
    
            }
    
        }
    
        function drawXlines() {
    
            // loop through every line in the points array
            for (const [n, L] of allPts.entries()) {
            
                // start the path at the first point
                let tmpD = 'M' + L[0].makeSVG();
            
                // loop through all remaining points
                for (let i = 1, j = L.length; i < j; i++) {
                    tmpD += 'L' + L[i].makeSVG();
                }
            
                // add the path to the svg tag
                if (L[0].oy === 0) {
                    xaxis.setAttribute('d', tmpD);
                } else {
                    xlines.childNodes[n].setAttribute('d', tmpD);
                }
            
            }

        }
    
        function drawYlines() {
    
            // loop through the y-lines array
            for (const [n, L] of yPts.entries()) {
                
                // start the path at the first point
                let tmpD = 'M' + L[0].makeSVG();
                
                // loop through all remaining points
                for (let i = 1, j = L.length; i < j; i++) {
                    tmpD += 'L' + L[i].makeSVG();
                }
                
                // add the path to the svg tag
                if (L[0].ox === 0) {
                    yaxis.setAttribute('d', tmpD);
                } else {
                    ylines.childNodes[n].setAttribute('d', tmpD);
                }

            }
    
        }
        
        function update(val = 0) {
            
            // recalc the masses
            masses.forEach(M => M.recalc(val * valScale));
    
            // recalc the grid points
            for (let AP of allPts) {
                
                for (let p of AP) {
                    
                    p.recalc(val * valScale);
                    
                }
                
            }
    
            // draw the x-lines
            drawXlines();
    
            // draw the y-lines
            drawYlines();
    
        }
    
        //}
    
        ////////////////////////////////////////////////////////////
    
        // create the masses {
        for (let M in masses) { masses[M] = new Mass(...masses[M]); }
        //}
    
        // fill the points array {
        for (let L in allPts) {
            allPts[L] = (new Array(1 + (2 * xdim / size))).fill(0);
            for (let P in allPts[L]) {
                allPts[L][P] = new Point(-xdim + P * size, -ydim + L * size);
            }
        }
    
        // rotate that matrix for y-lines
        for (let L in allPts[0]) {
    
            yPts[L] = [];
    
            for (let i = 0, j = allPts.length; i < j; i++) {
                yPts[L].push(allPts[i][L]);
            }
    
        }
        //}
    
        // create the lines {
        createXlines();
        createYlines();
        xaxis.style.strokeWidth = yaxis.style.strokeWidth = axisWidth;
        //}
    
        // draw the scene {
        update();
        //}
    
        ////////////////////////////////////////////////////////////
    
        // handlers {
        
        for (let [x, y, z] of [
    
            [svgHolder, 'wheel', e => {
            
                e.preventDefault();
            
                if (Math.abs(e.deltaX) > 5) {
                    let c = count;
                    c = [0, c + 1 * Math.sign(e.deltaX), 100]
                        .sort((a, b) => a - b)[1];
            
                    if (c !== count) {
                        count = c;
                        update(count);
                    }
            
                }
            
            }],
    
            [svgHolder, 'dblclick', e => {
                e.preventDefault();
                (count = 0);
                update(count);
            }]
    
        ]) {
            x.addEventListener(y, z, {passive:false});
        }
        //}

// expire msg {
    
}))()

=== undefined || (console.log('eXp!red'));

// }

</script>

</html>